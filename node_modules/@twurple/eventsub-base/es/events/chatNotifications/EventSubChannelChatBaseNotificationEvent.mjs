import { __decorate } from "tslib";
import { Enumerable } from '@d-fischer/shared-utils';
import { checkRelationAssertion, DataObject, rawDataSymbol, rtfm } from '@twurple/common';
/**
 * An EventSub event representing a notification being sent to a channel's chat.
 */
let EventSubChannelChatBaseNotificationEvent = class EventSubChannelChatBaseNotificationEvent extends DataObject {
    /** @internal */
    constructor(data, client) {
        super(data);
        this._client = client;
    }
    /**
     * The ID of the broadcaster.
     */
    get broadcasterId() {
        return this[rawDataSymbol].broadcaster_user_id;
    }
    /**
     * The name of the broadcaster.
     */
    get broadcasterName() {
        return this[rawDataSymbol].broadcaster_user_login;
    }
    /**
     * The display name of the broadcaster.
     */
    get broadcasterDisplayName() {
        return this[rawDataSymbol].broadcaster_user_name;
    }
    /**
     * Gets more information about the broadcaster.
     */
    async getBroadcaster() {
        return checkRelationAssertion(await this._client.users.getUserById(this[rawDataSymbol].broadcaster_user_id));
    }
    /**
     * Whether the chatter is anonymous.
     *
     * Only applies to some event types like sub gifts.
     */
    get chatterIsAnonymous() {
        return this[rawDataSymbol].chatter_is_anonymous;
    }
    /**
     * The ID of the chatter.
     */
    get chatterId() {
        return this[rawDataSymbol].chatter_user_id;
    }
    /**
     * The name of the chatter.
     */
    get chatterName() {
        return this[rawDataSymbol].chatter_user_login;
    }
    /**
     * The display name of the chatter.
     */
    get chatterDisplayName() {
        return this[rawDataSymbol].chatter_user_name;
    }
    /**
     * Gets more information about the chatter.
     */
    async getChatter() {
        return checkRelationAssertion(await this._client.users.getUserById(this[rawDataSymbol].chatter_user_id));
    }
    /**
     * The color of the chatter, or null if they didn't choose a color.
     */
    get color() {
        return this[rawDataSymbol].color || null;
    }
    /**
     * The badges the chatter has.
     *
     * The returned object contains the badge names as keys and the badge versions as the respective values.
     */
    get badges() {
        return Object.fromEntries(this[rawDataSymbol].badges.map(badge => [badge.set_id, badge.id]));
    }
    /**
     * Checks whether the chatter has the specified badge.
     *
     * @param name The name of the badge to check.
     */
    hasBadge(name) {
        return this[rawDataSymbol].badges.some(badge => badge.set_id === name);
    }
    /**
     * Gets the badge info for a specified badge, or null if the badge does not exist.
     *
     * @param name The name of the badge to get info for.
     */
    getBadgeInfo(name) {
        var _a, _b;
        return (_b = (_a = this[rawDataSymbol].badges.find(badge => badge.set_id === name)) === null || _a === void 0 ? void 0 : _a.info) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * The ID of the notification message.
     */
    get messageId() {
        return this[rawDataSymbol].message_id;
    }
    /**
     * The text that was sent with the notification, e.g. the resub message or announcement text.
     */
    get messageText() {
        return this[rawDataSymbol].message.text;
    }
    /**
     * The text that was sent with the notification, structured into pre-parsed parts.
     */
    get messageParts() {
        return this[rawDataSymbol].message.fragments;
    }
};
__decorate([
    Enumerable(false)
], EventSubChannelChatBaseNotificationEvent.prototype, "_client", void 0);
EventSubChannelChatBaseNotificationEvent = __decorate([
    rtfm('eventsub-base', 'EventSubChannelChatBaseNotificationEvent', 'broadcasterId')
], EventSubChannelChatBaseNotificationEvent);
export { EventSubChannelChatBaseNotificationEvent };
