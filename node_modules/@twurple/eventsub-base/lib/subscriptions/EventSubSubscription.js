"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventSubSubscription = void 0;
const tslib_1 = require("tslib");
const api_1 = require("@twurple/api");
const common_1 = require("@twurple/common");
/**
 * A subscription to an EventSub event.
 *
 * @hideProtected
 */
let EventSubSubscription = class EventSubSubscription {
    /** @internal */
    constructor(_handler, _client) {
        this._handler = _handler;
        this._client = _client;
        this._verified = false;
    }
    /**
     * Whether the subscription has been verified by Twitch.
     */
    get verified() {
        return this._verified;
    }
    /** @private */
    get _twitchId() {
        var _a;
        return (_a = this._twitchSubscriptionData) === null || _a === void 0 ? void 0 : _a.id;
    }
    /** @private */
    _verify() {
        this._verified = true;
    }
    /** @private */
    async _handleData(body) {
        await this._handler(this.transformData(body));
    }
    /**
     * Activates the subscription.
     *
     * You don't have to call this method manually after subscribing, as it's done automatically.
     * It's only used to reactivate a subscription after calling `.stop()`.
     *
     * @param resumeFrom The subscription data from Twitch to check whether the subscription needs to be re-added.
     */
    start(resumeFrom) {
        if (resumeFrom) {
            if (resumeFrom.status === 'enabled' || resumeFrom.status === 'webhook_callback_verification_pending') {
                this._twitchSubscriptionData = resumeFrom;
                this._verified = true;
                this._client._logger.debug(`Successfully resumed subscription for event: ${this.id}`);
                return;
            }
            this._client._logger.info(`Cycling broken conflicting subscription for event: ${this.id}`);
            this._unsubscribe().then(() => this._subscribeAndSave(), e => this._client._notifySubscriptionDeleteError(this, e));
        }
        else {
            this._subscribeAndSave();
        }
    }
    /**
     * Suspends the subscription, not removing it from the listener.
     */
    suspend() {
        if (!this._twitchSubscriptionData) {
            return;
        }
        this._unsubscribe().then(() => {
            this._verified = false;
            this._twitchSubscriptionData = undefined;
        }, e => this._client._notifySubscriptionDeleteError(this, e));
    }
    /**
     * Deactivates the subscription and removes it from the listener.
     */
    stop() {
        this.suspend();
        this._client._dropSubscription(this.id);
    }
    /**
     * Outputs the base command to execute for testing the subscription using the Twitch CLI.
     *
     * Some additional parameters, like the target user, may be required.
     */
    async getCliTestCommand() {
        return await this._client._getCliTestCommandForSubscription(this);
    }
    /** @private */
    _droppedByTwitch() {
        this._twitchSubscriptionData = undefined;
        this._verified = false;
    }
    async _getTransportOptions() {
        return await this._client._getTransportOptionsForSubscription(this);
    }
    _subscribeAndSave() {
        this._subscribe().then(data => {
            this._twitchSubscriptionData = data;
            this._client._registerTwitchSubscription(this, data);
        }, e => {
            var _a;
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            this._client._logger.error(`Subscription ${this.id} failed to subscribe: ${(_a = e.message) !== null && _a !== void 0 ? _a : e}`);
            this._client._notifySubscriptionCreateError(this, e);
        });
    }
    async _unsubscribe() {
        if (this._twitchSubscriptionData) {
            const subscriptionId = this._twitchSubscriptionData.id;
            if (this._twitchSubscriptionData._transport.method === 'websocket') {
                if (!this.authUserId) {
                    throw new api_1.HellFreezesOverError(`Trying to delete a websocket subscription that does not have user context (${this.id})`);
                }
                await this._client._apiClient.asUser(this.authUserId, async (ctx) => await ctx.eventSub.deleteSubscription(subscriptionId));
            }
            else {
                await this._client._apiClient.withoutUser(async (ctx) => await ctx.eventSub.deleteSubscription(subscriptionId));
            }
        }
        this._client._dropTwitchSubscription(this.id);
        this._client._notifySubscriptionDeleteSuccess(this);
    }
};
exports.EventSubSubscription = EventSubSubscription;
exports.EventSubSubscription = EventSubSubscription = tslib_1.__decorate([
    (0, common_1.rtfm)('eventsub-base', 'EventSubSubscription')
], EventSubSubscription);
