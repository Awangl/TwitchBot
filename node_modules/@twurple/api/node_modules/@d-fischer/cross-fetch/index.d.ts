// Type definitions for node-fetch 2.6
// Project: https://github.com/bitinn/node-fetch
// Abridged by d-fischer <daniel@d-fischer.dev> for cross-fetch fork
// Definitions by: Torsten Werner <https://github.com/torstenwerner>
//                 Niklas Lindgren <https://github.com/nikcorg>
//                 Vinay Bedre <https://github.com/vinaybedre>
//                 Antonio Rom√°n <https://github.com/kyranet>
//                 Andrew Leedham <https://github.com/AndrewLeedham>
//                 Jason Li <https://github.com/JasonLi914>
//                 Steve Faulkner <https://github.com/southpolesteve>
//                 ExE Boss <https://github.com/ExE-Boss>
//                 Alex Savin <https://github.com/alexandrusavin>
//                 Alexis Tyler <https://github.com/OmgImAlexis>
//                 Jakub Kisielewski <https://github.com/kbkk>
//                 David Glasser <https://github.com/glasser>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

export class Request extends Body {
  constructor(input: RequestInfo, init?: RequestInit);
  clone(): Request;
  headers: Headers;
  method: string;
  referrer: string;
  url: string;
}

export type RequestRedirect = "error" | "follow" | "manual";

export interface RequestInit {
  body?: BodyInit | undefined;
  headers?: HeadersInit | undefined;
  method?: string | undefined;
  redirect?: RequestRedirect | undefined;
}

export class Headers implements Iterable<[string, string]> {
  constructor(init?: HeadersInit);
  forEach(callback: (value: string, name: string) => void): void;
  append(name: string, value: string): void;
  delete(name: string): void;
  get(name: string): string | null;
  has(name: string): boolean;
  raw(): { [k: string]: string[] };
  set(name: string, value: string): void;

  // Iterable methods
  entries(): IterableIterator<[string, string]>;
  keys(): IterableIterator<string>;
  values(): IterableIterator<string>;
  [Symbol.iterator](): Iterator<[string, string]>;
}

type BlobPart = ArrayBuffer | ArrayBufferView | Blob | string;

interface BlobOptions {
  type?: string | undefined;
  endings?: "transparent" | "native" | undefined;
}

export class Blob {
  constructor(blobParts?: BlobPart[], options?: BlobOptions);
  readonly type: string;
  readonly size: number;
  slice(start?: number, end?: number): Blob;
  text(): Promise<string>;
}

export class Body {
  constructor(body?: any, opts?: { size?: number | undefined; timeout?: number | undefined });
  arrayBuffer(): Promise<ArrayBuffer>;
  blob(): Promise<Blob>;
  body: NodeJS.ReadableStream;
  bodyUsed: boolean;
  json(): Promise<any>;
  text(): Promise<string>;
}

export class Response extends Body {
  constructor(body?: BodyInit, init?: ResponseInit);
  static error(): Response;
  static redirect(url: string, status: number): Response;
  clone(): Response;
  headers: Headers;
  ok: boolean;
  redirected: boolean;
  status: number;
  statusText: string;
  type: ResponseType;
  url: string;
}

export type ResponseType =
  "basic"
  | "cors"
  | "default"
  | "error"
  | "opaque"
  | "opaqueredirect";

export interface ResponseInit {
  headers?: HeadersInit | undefined;
  status?: number | undefined;
  statusText?: string | undefined;
}

interface URLLike {
  href: string;
}

export type HeadersInit = Headers | string[][] | { [key: string]: string };
export type BodyInit =
  ArrayBuffer
  | ArrayBufferView
  | string
export type RequestInfo = string | URLLike | Request;

declare function fetch(
  url: RequestInfo,
  init?: RequestInit
): Promise<Response>;

declare namespace fetch {
  function isRedirect(code: number): boolean;
}

export default fetch;
